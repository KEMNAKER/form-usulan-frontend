"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RESOLVE_MATCH = exports.REDIRECT_ACTION_TYPE = exports.GOTO_ACTION_TYPE = void 0;
Object.defineProperty(exports, "Redirect", {
  enumerable: true,
  get: function get() {
    return _found.Redirect;
  }
});
Object.defineProperty(exports, "RedirectException", {
  enumerable: true,
  get: function get() {
    return _found.RedirectException;
  }
});
Object.defineProperty(exports, "Route", {
  enumerable: true,
  get: function get() {
    return _found.Route;
  }
});
exports._RESOLVE_MATCH = exports.UPDATE_MATCH = void 0;
exports.convertRoutes = convertRoutes;
exports.createRouterStoreEnhancers = createRouterStoreEnhancers;
Object.defineProperty(exports, "foundReducer", {
  enumerable: true,
  get: function get() {
    return _found.foundReducer;
  }
});
exports.getCurrentlyMatchedLocation = getCurrentlyMatchedLocation;
exports.getMatchedRoutes = getMatchedRoutes;
exports.getMatchedRoutesIndices = getMatchedRoutesIndices;
exports.getMatchedRoutesParams = getMatchedRoutesParams;
exports.getPreviouslyMatchedLocation = getPreviouslyMatchedLocation;
exports.getRouteParams = getRouteParams;
exports.getRoutePath = getRoutePath;
exports.getRoutesByPath = getRoutesByPath;
exports.goBack = goBack;
exports.goBackTwoPages = goBackTwoPages;
exports.goForward = goForward;
exports["goto"] = void 0;
exports.initializeRouter = initializeRouter;
exports.matchRoutes = matchRoutes;
exports.pushLocation = pushLocation;
exports.redirect = void 0;
exports.replaceLocation = replaceLocation;
Object.defineProperty(exports, "useRouter", {
  enumerable: true,
  get: function get() {
    return _found.useRouter;
  }
});
var _found = require("@catamphetamine/found");
var _farce = require("farce");
var _instantNavigation = require("../redux/client/instantNavigation.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function createRouterStoreEnhancers(routes, createHistoryProtocol) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var middlewares = [_farce.queryMiddleware];
  if (options.basename) {
    middlewares.push((0, _farce.createBasenameMiddleware)({
      basename: options.basename
    }));
  }
  return [(0, _farce.createHistoryEnhancer)({
    protocol: createHistoryProtocol(),
    middlewares: middlewares
  }), (0, _found.createMatchEnhancer)(
  // new Matcher(hotRouteConfig(routes))
  new _found.Matcher(routes))];
}
function matchRoutes(store) {
  return (0, _found.getStoreRenderArgs)({
    store: store,
    resolver: _found.resolver,
    matchContext: {
      dispatch: store.dispatch,
      getState: store.getState
    }
  }).then(function (renderArgs) {
    if (renderArgs.error) {
      throw renderArgs.error;
    }
    return renderArgs;
  });
}
function getRoutesByPath(routeIndices, routes) {
  var matchedRoutes = [];
  var _iterator = _createForOfIteratorHelper(routeIndices),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var i = _step.value;
      matchedRoutes.push(routes[i]);
      routes = routes[i].children;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return matchedRoutes;
}
function getMatchedRoutes(state, routes) {
  return getRoutesByPath(state.found.match.routeIndices, routes);
}
function getMatchedRoutesIndices(state) {
  return state.found.match.routeIndices;
}

// A URL can consist of several "routes": a parent route + possible sub-routes.
// "Matched route params" are just this particular route's params for a given URL.
// All routes' params are the combined params for all matched routes for a given URL.
//
// Example:
//
// const routes = [{
//   path: ':foo',
//   children: [{
//     path: ':bar'
//   }]
// }]
//
// const location = {
//   pathname: '/a/b'
// }
//
// const routeParams = [
// 	{ foo: 'a' },
// 	{ bar: 'b' }
// ]
//
// const params = {
//   foo: 'a',
//   bar: 'b'
// }
//
function getMatchedRoutesParams(state) {
  return state.found.match.routeParams;
}
function getRouteParams(state) {
  var routeIndices = getMatchedRoutesIndices(state);
  return state.found.match.params;
}
function getCurrentlyMatchedLocation(state) {
  return state.found.match.location;
}
function getPreviouslyMatchedLocation(state) {
  return state.found.resolvedMatch &&
  // state.found.resolvedMatch.location.key === undefined &&
  state.found.resolvedMatch.location;
}

// Returns a complete route path for matched routes chain.
// E.g. returns "/user/:user_id/post/:post_id"
// for matched URL "/user/1/post/123?key=value".
function getRoutePath(routes) {
  return routes
  // Select routes having `path` React property set.
  .filter(function (route) {
    return route.path;
  })
  // Trim leading and trailing slashes (`/`)
  // from each route `path` React property.
  .map(function (route) {
    return route.path.replace(/^\//, '').replace(/\/$/, '');
  })
  // Join route `path`s with slashes (`/`).
  .join('/') || '/';
}
function convertRoutes(routes) {
  return (0, _found.makeRouteConfig)(routes);
}
function initializeRouter(store) {
  store.dispatch(_farce.Actions.init());
}
var redirect = _farce.Actions.replace;
exports.redirect = redirect;
var _goto = function _goto(location) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  (0, _instantNavigation.markImmediateNavigationAsInstantBack)(options.instantBack);
  return _farce.Actions.push(location);
};
exports["goto"] = _goto;
var REDIRECT_ACTION_TYPE = _farce.ActionTypes.REPLACE;
exports.REDIRECT_ACTION_TYPE = REDIRECT_ACTION_TYPE;
var GOTO_ACTION_TYPE = _farce.ActionTypes.PUSH;
exports.GOTO_ACTION_TYPE = GOTO_ACTION_TYPE;
function goBack() {
  return _farce.Actions.go(-1);
}
function goBackTwoPages() {
  return _farce.Actions.go(-2);
}
function goForward() {
  return _farce.Actions.go(1);
}
function pushLocation(location, options) {
  window._ReactPages_Page_SkipDataLoad_on_navigation = true;
  return _goto(location, options);
}
function replaceLocation(location) {
  window._ReactPages_Page_SkipDataLoad_on_navigation = true;
  return redirect(location);
}
var UPDATE_MATCH = _found.ActionTypes.UPDATE_MATCH;
exports.UPDATE_MATCH = UPDATE_MATCH;
var RESOLVE_MATCH = _found.ActionTypes.RESOLVE_MATCH;
exports.RESOLVE_MATCH = RESOLVE_MATCH;
var _RESOLVE_MATCH = '@@react-pages/RESOLVE_MATCH';
exports._RESOLVE_MATCH = _RESOLVE_MATCH;
//# sourceMappingURL=index.js.map