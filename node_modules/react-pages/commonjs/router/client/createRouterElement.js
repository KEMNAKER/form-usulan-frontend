"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = createRouterElement;
var _react = _interopRequireDefault(require("react"));
var _found = require("@catamphetamine/found");
var _foundScroll = require("@catamphetamine/found-scroll");
var _RouteProvider = _interopRequireDefault(require("../RouteProvider.js"));
var _render2 = _interopRequireDefault(require("../render.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
// `@catamphetamine/found` is the same as `found`
// with the only change being that `redux` and `react-redux` packages
// were moved from `dependencies` to `peerDependencies` in `package.json`.

// `@catamphetamine/found-scroll` is the same as `found-scroll`
// with the only change being that in its `peerDependencies`
// `found` was replaced with `@catamphetamine/found`.
// The reason is that `found` package is not installed due to not being used
// and `@catamphetamine/found` package is being used instead of it.

function createRouterElement(renderArgs, _ref) {
  var dispatch = _ref.dispatch,
    getState = _ref.getState;
  var ConnectedRouter = (0, _found.createConnectedRouter)({
    render: function render(renderArgs) {
      // Force re-mount the last route component on location path change.
      // https://github.com/4Catalyzer/found/issues/199#issuecomment-415616836
      var elements = renderArgs.elements;
      if (elements && window.reactPagesRemountOnNavigate !== false) {
        elements[elements.length - 1] = _react["default"].cloneElement(elements[elements.length - 1], {
          key: renderArgs.location.pathname
        });
      }
      // When a user navigates to a page, this `render()` function is called:
      // * If there's any `load()` data loader:
      //   * The first call is gonna be with `elements: undefined` and the new `location`,
      //     before the page starts loading the initial data.
      //     `<RouteProvider/>` ignores this `render()` call.
      //   * The second call is gonna be with `elements: React.Element[]` and the new `location`,
      //     after the page has loaded the initial data.
      // * Otherwise, if there's no data to load:
      //   * The page just renders with `elements: React.Element[]` and the new `location`.
      return _react["default"].createElement(_RouteProvider["default"], {
        // `elements` is `undefined` when router starts loading the next page.
        // In that case, the previous page is still rendered, so it shouldn't
        // pass the new `location` to `<RouteProvider/>` yet.
        location: elements && renderArgs.location,
        params: elements && renderArgs.params,
        routes: elements && renderArgs.routes
      }, _react["default"].createElement(_foundScroll.ScrollManager, {
        renderArgs: renderArgs
      }, (0, _render2["default"])(renderArgs)));
    }
  });
  return _react["default"].createElement(ConnectedRouter, {
    matchContext: {
      dispatch: dispatch,
      getState: getState
    },
    resolver: _found.resolver,
    initialRenderArgs: renderArgs
  });
}
//# sourceMappingURL=createRouterElement.js.map