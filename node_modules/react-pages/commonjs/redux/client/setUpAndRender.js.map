{"version":3,"file":"setUpAndRender.js","names":["setUpAndRender","settings","options","normalizeSettings","resetInstantNavigationChain","showLoadingInitially","isServerSidePreloaded","window","_ReactPages_Page_ServerSideRenderedPageRestorationPrerender","_ReactPages_Page_SkipDataLoad","store","createStore","showingInitialPreload","showInitialPreload","clientSideRender","container","render","renderParameters","then","result","dispatch","redirect","document","location","hideInitialPreload","type","_RESOLVE_MATCH","payload","_ReactPages_SimulatedResolveMatchEventPayload","error","RedirectException","key","indexOf","undefined","pushLocation","_ReactPages_Navigation_IgnoreResolveMatchEvent","RESOLVE_MATCH","getState","found","match"],"sources":["../../../lib/redux/client/setUpAndRender.js"],"sourcesContent":["import clientSideRender from '../../client/render.js'\r\nimport { isServerSidePreloaded } from '../../client/flags.js'\r\nimport { RESOLVE_MATCH } from '../../router/index.js'\r\nimport render from './render.js'\r\nimport normalizeSettings from '../normalize.js'\r\nimport createStore from './createStore.js'\r\nimport { resetInstantNavigationChain } from './instantNavigation.js'\r\nimport { redirect, _RESOLVE_MATCH, pushLocation, RedirectException } from '../../router/index.js'\r\nimport { showInitialPreload, hideInitialPreload } from './initialPreload.js'\r\n\r\n// This function is what's gonna be called from the project's code on the client-side.\r\n//\r\n// There are two passes of client-side render happening here.\r\n// React has the concept of \"re-hydration\" which demands that\r\n// the initial client-side React rendering results be equal to\r\n// the server-side React rendering results, character-by-character.\r\n// Otherwise it complains.\r\n// That's the reason why the application on client side first performs\r\n// a \"dummy\" rendering without resolving any `load`s, just to complete\r\n// the React \"hydration\" process, and only when the \"hydration\" process finishes\r\n// does it perform the second pass of rendering the page,\r\n// now resolving all client-side `load`s.\r\n// Therefore, the first pass of `.render()`Â always happens with data missing\r\n// if that data is loaded in \"client-side only\" `load`s.\r\n// (that is, the `load`s configured with `{ client: true }`).\r\n//\r\n// If React \"re-hydration\" step didn't exist\r\n// then the library would first execute all client-side preloads\r\n// and only then would it render the application.\r\n// That would be more intuitive and convenient for developers I guess.\r\n//\r\nexport default function setUpAndRender(settings, options) {\r\n\tsettings = normalizeSettings(settings)\r\n\r\n\t// Reset \"instant back\" on page reload\r\n\t// since Redux state is cleared.\r\n\t// \"instant back\" chain is stored in `window.sessionStorage`\r\n\t// and therefore it survives page reload.\r\n\tresetInstantNavigationChain()\r\n\r\n\t// `showLoadingInitially` is handled in a special way\r\n\t// in case of client-side-only rendering.\r\n\tconst { showLoadingInitially } = settings\r\n\r\n\t// The first pass of initial client-side render\r\n\t// is to render the markup which matches server-side one.\r\n\t// The second pass will be to render after resolving `getData`.\r\n\tif (isServerSidePreloaded()) {\r\n\t\twindow._ReactPages_Page_ServerSideRenderedPageRestorationPrerender = true\r\n\t\twindow._ReactPages_Page_SkipDataLoad = true\r\n\t}\r\n\r\n\t// Create a Redux `store` if not passed.\r\n\tif (!settings.store) {\r\n\t\t// Create a Redux store (and, internally, an HTTP client).\r\n\t\t// Mutate `settings` because they're passed again \"recursively\"\r\n\t\t// in a `catch` clause below.\r\n\t\tsettings.store = createStore(settings, options)\r\n\t}\r\n\r\n\tconst { store } = settings\r\n\r\n\t// Render loading indicator in case of client-side-only rendering\r\n\t// because the main application React tree won't be rendered\r\n\t// until `load`s finish.\r\n\tlet showingInitialPreload = false\r\n\tif (!isServerSidePreloaded() && showLoadingInitially) {\r\n\t\tshowInitialPreload()\r\n\t\tshowingInitialPreload = true\r\n\t}\r\n\r\n\t// Render the page.\r\n\t// If it's a server-side rendering case then that will be the\r\n\t// first pass, without loading data, just for `React.hydrate()`.\r\n\t// If it's a client-side rendering case then that will be the\r\n\t// first pass with loading data.\r\n\treturn clientSideRender({\r\n\t\tcontainer: settings.container,\r\n\t\trender,\r\n\t\trenderParameters: {\r\n\t\t\tstore\r\n\t\t}\r\n\t})\r\n\t.then((result) => {\r\n\t\t// Perform the second pass of initial client-side rendering.\r\n\t\t// The second pass resolves `getData` on routes.\r\n\t\t// (which means it resolves all client-side `load`s)\r\n\t\tif (isServerSidePreloaded()) {\r\n\t\t\tstore.dispatch(redirect(document.location))\r\n\t\t} else {\r\n\t\t\t// Hide the \"initial\" loading indicator.\r\n\t\t\tif (showingInitialPreload) {\r\n\t\t\t\thideInitialPreload()\r\n\t\t\t}\r\n\t\t\t// `RESOLVE_MATCH` is not being dispatched\r\n\t\t\t// for the first render for some reason.\r\n\t\t\t// https://github.com/4Catalyzer/found/issues/202\r\n\t\t\t// With server-side rendering enabled\r\n\t\t\t// initially there are two rendering passes\r\n\t\t\t// and therefore `RESOLVE_MATCH` does get dispatched\r\n\t\t\t// after the page is initialized and rendered.\r\n\t\t\t// With server-side rendering disabled\r\n\t\t\t// `RESOLVE_MATCH` does not get dispatched\r\n\t\t\t// therefore a custom `_RESOLVE_MATCH` event is\r\n\t\t\t// dispatched manually.\r\n\t\t\tstore.dispatch({\r\n\t\t\t\ttype: _RESOLVE_MATCH,\r\n\t\t\t\tpayload: window._ReactPages_SimulatedResolveMatchEventPayload\r\n\t\t\t})\r\n\t\t}\r\n\t\treturn result\r\n\t}, (error) => {\r\n\t\t// Hide the \"initial\" loading indicator.\r\n\t\tif (showingInitialPreload) {\r\n\t\t\thideInitialPreload()\r\n\t\t}\r\n\r\n\t\t// Catches redirects from `load`s,\r\n\t\t// redirects from `onError` and from `<Redirect/>` routes.\r\n\t\tif (error instanceof RedirectException) {\r\n\t\t\t// Reset all `react-pages` flags related to:\r\n\t\t\t// * the current page properties.\r\n\t\t\t// * the current navigation properties.\r\n\t\t\t// * the navigation chain so far.\r\n\t\t\tfor (const key in window) {\r\n\t\t\t\tif (key.indexOf('_ReactPages_Page_') === 0 || key.indexOf('_ReactPages_Navigation_') === 0) {\r\n\t\t\t\t\twindow[key] = undefined\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Change current location.\r\n\t\t\t// Emits a `UPDATE_MATCH` event.\r\n\t\t\t// `error.location` can be a `string`.\r\n\t\t\t// Maybe it could be a location `object` too.\r\n\t\t\tstore.dispatch(pushLocation(error.location))\r\n\r\n\t\t\t// Simply emitting an `UPDATE_MATCH` event again\r\n\t\t\t// wouldn't work for the second navigation\r\n\t\t\t// the way it worked for the initial one.\r\n\t\t\t//\r\n\t\t\t// The reason is that `found` router has a special case for handling\r\n\t\t\t// the \"initial\" `UPDATE_MATCH` event:\r\n\t\t\t//\r\n\t\t\t// https://github.com/4Catalyzer/found/blob/63a44a633159d6e16161e407fa4d6869fdb70623/src/foundReducer.ts\r\n\t\t\t//\r\n\t\t\t// switch (type) {\r\n\t\t\t//   case ActionTypes.UPDATE_MATCH:\r\n\t\t\t//     // For the initial match, set resolvedMatch too. There's no previous\r\n\t\t\t//     // result to keep rendered, plus this simplifies server rendering.\r\n\t\t\t//     return {\r\n\t\t\t//       match: payload,\r\n\t\t\t//       resolvedMatch: state ? state.resolvedMatch : payload\r\n\t\t\t//     }\r\n\t\t\t//   ...\r\n\t\t\t// }\r\n\t\t\t//\r\n\t\t\t// For that reason, first set `state.found.resolvedMatch` to `state.found.match`.\r\n\t\t\t//\r\n\t\t\twindow._ReactPages_Navigation_IgnoreResolveMatchEvent = true\r\n\t\t\tstore.dispatch({\r\n\t\t\t\ttype: RESOLVE_MATCH,\r\n\t\t\t\tpayload: store.getState().found.match\r\n\t\t\t})\r\n\r\n\t\t\t// Re-render.\r\n\t\t\treturn setUpAndRender(settings, options)\r\n\t\t}\r\n\t\tthrow error\r\n\t})\r\n}"],"mappings":"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"}