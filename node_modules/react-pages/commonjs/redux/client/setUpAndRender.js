"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = setUpAndRender;
var _render = _interopRequireDefault(require("../../client/render.js"));
var _flags = require("../../client/flags.js");
var _index = require("../../router/index.js");
var _render2 = _interopRequireDefault(require("./render.js"));
var _normalize = _interopRequireDefault(require("../normalize.js"));
var _createStore = _interopRequireDefault(require("./createStore.js"));
var _instantNavigation = require("./instantNavigation.js");
var _initialPreload = require("./initialPreload.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
// This function is what's gonna be called from the project's code on the client-side.
//
// There are two passes of client-side render happening here.
// React has the concept of "re-hydration" which demands that
// the initial client-side React rendering results be equal to
// the server-side React rendering results, character-by-character.
// Otherwise it complains.
// That's the reason why the application on client side first performs
// a "dummy" rendering without resolving any `load`s, just to complete
// the React "hydration" process, and only when the "hydration" process finishes
// does it perform the second pass of rendering the page,
// now resolving all client-side `load`s.
// Therefore, the first pass of `.render()`Â always happens with data missing
// if that data is loaded in "client-side only" `load`s.
// (that is, the `load`s configured with `{ client: true }`).
//
// If React "re-hydration" step didn't exist
// then the library would first execute all client-side preloads
// and only then would it render the application.
// That would be more intuitive and convenient for developers I guess.
//
function setUpAndRender(settings, options) {
  settings = (0, _normalize["default"])(settings);

  // Reset "instant back" on page reload
  // since Redux state is cleared.
  // "instant back" chain is stored in `window.sessionStorage`
  // and therefore it survives page reload.
  (0, _instantNavigation.resetInstantNavigationChain)();

  // `showLoadingInitially` is handled in a special way
  // in case of client-side-only rendering.
  var _settings = settings,
    showLoadingInitially = _settings.showLoadingInitially;

  // The first pass of initial client-side render
  // is to render the markup which matches server-side one.
  // The second pass will be to render after resolving `getData`.
  if ((0, _flags.isServerSidePreloaded)()) {
    window._ReactPages_Page_ServerSideRenderedPageRestorationPrerender = true;
    window._ReactPages_Page_SkipDataLoad = true;
  }

  // Create a Redux `store` if not passed.
  if (!settings.store) {
    // Create a Redux store (and, internally, an HTTP client).
    // Mutate `settings` because they're passed again "recursively"
    // in a `catch` clause below.
    settings.store = (0, _createStore["default"])(settings, options);
  }
  var _settings2 = settings,
    store = _settings2.store;

  // Render loading indicator in case of client-side-only rendering
  // because the main application React tree won't be rendered
  // until `load`s finish.
  var showingInitialPreload = false;
  if (!(0, _flags.isServerSidePreloaded)() && showLoadingInitially) {
    (0, _initialPreload.showInitialPreload)();
    showingInitialPreload = true;
  }

  // Render the page.
  // If it's a server-side rendering case then that will be the
  // first pass, without loading data, just for `React.hydrate()`.
  // If it's a client-side rendering case then that will be the
  // first pass with loading data.
  return (0, _render["default"])({
    container: settings.container,
    render: _render2["default"],
    renderParameters: {
      store: store
    }
  }).then(function (result) {
    // Perform the second pass of initial client-side rendering.
    // The second pass resolves `getData` on routes.
    // (which means it resolves all client-side `load`s)
    if ((0, _flags.isServerSidePreloaded)()) {
      store.dispatch((0, _index.redirect)(document.location));
    } else {
      // Hide the "initial" loading indicator.
      if (showingInitialPreload) {
        (0, _initialPreload.hideInitialPreload)();
      }
      // `RESOLVE_MATCH` is not being dispatched
      // for the first render for some reason.
      // https://github.com/4Catalyzer/found/issues/202
      // With server-side rendering enabled
      // initially there are two rendering passes
      // and therefore `RESOLVE_MATCH` does get dispatched
      // after the page is initialized and rendered.
      // With server-side rendering disabled
      // `RESOLVE_MATCH` does not get dispatched
      // therefore a custom `_RESOLVE_MATCH` event is
      // dispatched manually.
      store.dispatch({
        type: _index._RESOLVE_MATCH,
        payload: window._ReactPages_SimulatedResolveMatchEventPayload
      });
    }
    return result;
  }, function (error) {
    // Hide the "initial" loading indicator.
    if (showingInitialPreload) {
      (0, _initialPreload.hideInitialPreload)();
    }

    // Catches redirects from `load`s,
    // redirects from `onError` and from `<Redirect/>` routes.
    if (error instanceof _index.RedirectException) {
      // Reset all `react-pages` flags related to:
      // * the current page properties.
      // * the current navigation properties.
      // * the navigation chain so far.
      for (var key in window) {
        if (key.indexOf('_ReactPages_Page_') === 0 || key.indexOf('_ReactPages_Navigation_') === 0) {
          window[key] = undefined;
        }
      }

      // Change current location.
      // Emits a `UPDATE_MATCH` event.
      // `error.location` can be a `string`.
      // Maybe it could be a location `object` too.
      store.dispatch((0, _index.pushLocation)(error.location));

      // Simply emitting an `UPDATE_MATCH` event again
      // wouldn't work for the second navigation
      // the way it worked for the initial one.
      //
      // The reason is that `found` router has a special case for handling
      // the "initial" `UPDATE_MATCH` event:
      //
      // https://github.com/4Catalyzer/found/blob/63a44a633159d6e16161e407fa4d6869fdb70623/src/foundReducer.ts
      //
      // switch (type) {
      //   case ActionTypes.UPDATE_MATCH:
      //     // For the initial match, set resolvedMatch too. There's no previous
      //     // result to keep rendered, plus this simplifies server rendering.
      //     return {
      //       match: payload,
      //       resolvedMatch: state ? state.resolvedMatch : payload
      //     }
      //   ...
      // }
      //
      // For that reason, first set `state.found.resolvedMatch` to `state.found.match`.
      //
      window._ReactPages_Navigation_IgnoreResolveMatchEvent = true;
      store.dispatch({
        type: _index.RESOLVE_MATCH,
        payload: store.getState().found.match
      });

      // Re-render.
      return setUpAndRender(settings, options);
    }
    throw error;
  });
}
//# sourceMappingURL=setUpAndRender.js.map