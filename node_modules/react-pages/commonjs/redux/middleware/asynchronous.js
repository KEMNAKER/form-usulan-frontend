"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RESULT_ACTION_PROPERTY = exports.ERROR_ACTION_PROPERTY = void 0;
exports["default"] = asynchronousMiddleware;
var _isObject = _interopRequireDefault(require("../../isObject.js"));
var _getLocationUrl = _interopRequireDefault(require("../../getLocationUrl.js"));
var _index = require("../../router/index.js");
var _naming = require("../naming.js");
var _excluded = ["promise", "event", "events"];
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
var RESULT_ACTION_PROPERTY = 'value';
exports.RESULT_ACTION_PROPERTY = RESULT_ACTION_PROPERTY;
var ERROR_ACTION_PROPERTY = 'error';

// Asynchronous middleware (e.g. for HTTP Ajax calls).
//
// Takes effect only if the `dispatch`ed action has
// `promise` function and `events` (or `event`) property.
//
// `dispatch()` call will return a `Promise`.
//
exports.ERROR_ACTION_PROPERTY = ERROR_ACTION_PROPERTY;
function asynchronousMiddleware(httpClient, reduxEventNaming, server, onError) {
  var parseError = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : defaultParseError;
  reduxEventNaming = reduxEventNaming || _naming.DEFAULT_REDUX_EVENT_NAMING;
  return function (_ref) {
    var dispatch = _ref.dispatch,
      getState = _ref.getState;
    return function (next) {
      return function (action) {
        var promise = action.promise,
          event = action.event,
          events = action.events,
          rest = _objectWithoutProperties(action, _excluded);

        // If the dispatched action doesn't have a `promise` function property then do nothing
        if (typeof promise !== 'function') {
          return next(action);
        }

        // Generate the three event names automatically based on a base event name
        if (!events && typeof event === 'string') {
          events = reduxEventNaming(event);
        }

        // Validate `events` property
        if (!events || events.length !== 3) {
          throw new Error("\"events\" property must be an array of 3 event names: e.g. ['pending', 'success', 'error']");
        }

        // event names
        var _events = events,
          _events2 = _slicedToArray(_events, 3),
          Request = _events2[0],
          Success = _events2[1],
          Failure = _events2[2];

        // dispatch the `pending` event to the Redux store
        dispatch(_objectSpread(_objectSpread({}, rest), {}, {
          type: Request
        }));

        // Run the asychronous action (e.g. an HTTP request)
        var promised = promise({
          http: httpClient
        });

        // Validate that `promise()` actually returned a `Promise`
        if (!promised || typeof promised.then !== 'function') {
          console.error('Redux action\'s "promise" function returned:', promised);
          throw new Error('Redux action\'s "promise" function must return a Promise.');
        }

        // Returning the result like this,
        // because if returned the `promised.then()` chain directly
        // then it wouldn't get detected as an "Unhandled rejection"
        // in case of an error.
        return new Promise(function (resolve, reject) {
          // Don't `return` this promise
          // so that it detects it as an "Unhandled rejection"
          // in case of an error.
          promised.then(
          // If the Promise resolved
          // (e.g. an HTTP request succeeded)
          function (result) {
            // Dispatch the `success` event to the Redux store
            dispatch(_objectSpread(_objectSpread({}, rest), {}, _defineProperty({
              type: Success
            }, RESULT_ACTION_PROPERTY, result)));

            // Returning the result like this,
            // because if returned the `promised.then()` chain directly
            // then it wouldn't get detected as an "Unhandled rejection"
            // in case of an error.
            resolve(result);

            // The Promise returned from `dispatch()` call
            // is resolved with the `promise` resolved value.
            return result;
          },
          // if the Http request failed
          //
          // (Http status !== 20x
          //  or the Http response JSON object has an `error` field)
          function (error) {
            // Dispatch the `failure` event to the Redux store
            dispatch(_objectSpread(_objectSpread({}, rest), {}, _defineProperty({
              type: Failure
            }, ERROR_ACTION_PROPERTY, parseError(error))));

            // The Promise returned from `dispatch()` call
            // is rejected with this error.

            // Also only checks `http` calls on client side
            // because on server side `http` calls can be
            // either part of `load` of part of `initialize`
            // which are already "error handled".
            // On the client side though, an `http` call
            // may be performed via some user input,
            // so it needs this separate case "error handler".
            if (!server && onError) {
              var location = getState().found.resolvedMatch.location;
              // Report the error
              // (for example, redirect to a login page
              //  if a JWT "access token" expired)
              onError(error, {
                path: location.pathname,
                url: (0, _getLocationUrl["default"])(location),
                // Using `goto` instead of `redirect` here
                // because it's not part of `load`
                // and is therefore part of some kind of an HTTP request
                // triggered by user input (e.g. form submission)
                // which means it is convenient to be able to
                // go "Back" to the page on which the error originated.
                redirect: function redirect(to) {
                  return dispatch((0, _index["goto"])(to));
                },
                dispatch: dispatch,
                getState: getState,
                server: server
              });
            }

            // Returning the result (error) like this,
            // because if returned the `promised.then()` chain directly
            // then it wouldn't get detected as an "Unhandled rejection"
            // in case of an error.
            reject(error);

            // Reduce client-side error reporting software (e.g. sentry.io)
            // noise for not-really-errors like "Unauthenticated" and "Unauthorized".
            if (error.status !== 401 && error.status !== 403) {
              throw error;
            }
          });
        });
      };
    };
  };
}

// Transform Javascript `Error` instance into a plain JSON object
// because the meaning of the `error` action is different
// from what `Error` class is: it should only carry info like
// `status`, `message` and possible other values (e.g. `code`),
// without any stack traces, line numbers, etc.
// I.e. the `error` action should be a plain javascript object,
// not an instance of an `Error` class, because it's Redux (stateless).
//
// Parses a `superagent` `Error` instance
// into a plain JSON object for storing it in Redux state.
// In case of an `application/json` HTTP response
// the `error` instance ha `.data` JSON object property
// which carries the `application/json` HTTP response data.
//
function defaultParseError(error) {
  // Copies JSON HTTP response entirely
  var errorData = (0, _isObject["default"])(error.data) ? error.data : {};

  // Sets HTTP response `status` code
  // if `status` property wasn't present in JSON HTTP response.
  if (errorData.status === undefined) {
    errorData.status = error.status;
  }

  // Copies `message` from `Error` instance
  // if `message` property wasn't present in JSON HTTP response.
  if (!errorData.message) {
    errorData.message = error.message;
  }
  return errorData;
}
//# sourceMappingURL=asynchronous.js.map