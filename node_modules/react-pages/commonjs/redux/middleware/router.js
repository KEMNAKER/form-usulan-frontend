"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = routerMiddleware;
var _index = require("../../router/index.js");
var _meta = require("../../meta/meta.js");
var _getLocationUrl = _interopRequireDefault(require("../../getLocationUrl.js"));
var _shouldSkipPreloadForNavigation = _interopRequireDefault(require("../preload/shouldSkipPreloadForNavigation.js"));
var _actions = require("../preload/actions.js");
var _instantNavigation = require("../client/instantNavigation.js");
var _flags = require("../../client/flags.js");
var _getDefaultMeta = _interopRequireDefault(require("../../meta/getDefaultMeta.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var ON_PAGE_LOADED_METHOD_NAME = 'onLoaded';

// Any events listened to here are being dispatched on client side.
function routerMiddleware(routes, codeSplit, onBeforeNavigate, onNavigate, reportStats, defaultMeta) {
  var startedAt;
  var previousLocation;
  var previousRouteIndices;
  return function (_ref) {
    var dispatch = _ref.dispatch,
      getState = _ref.getState;
    return function (next) {
      return function (event) {
        // Skip the first pass of the initial client-side render.
        // for the case when server-side rendering is used.
        if (window._ReactPages_Page_ServerSideRenderedPageRestorationPrerender) {
          return next(event);
        }
        var location = event.payload && event.payload.location;
        var routeIndices = event.payload && event.payload.routeIndices;
        switch (event.type) {
          // `UPDATE_MATCH` event is triggered when navigation starts.
          // `RESOLVE_MATCH` event is triggered when navigation ends.
          //
          case _index.UPDATE_MATCH:
            // A workaround for `found` router bug:
            // https://github.com/4Catalyzer/found/issues/239
            // Skip `load` and other stuff for anchor link navigation.
            if (previousLocation && (0, _shouldSkipPreloadForNavigation["default"])(previousLocation, location)) {
              // I guess this workaround won't work with `codeSplit: true`
              // because `codeSplit` doesn't use the global `getData` loader.
              if (!codeSplit) {
                break;
              }
            }

            // Store `event.payload` for the future `_UPDATE_MATCH` event.
            if (!window._ReactPages_RouterHasFinishedInitialRender && !(0, _flags.isServerSidePreloaded)()) {
              window._ReactPages_SimulatedResolveMatchEventPayload = event.payload;
            }

            // Measure `load` and `render` time.
            startedAt = Date.now();

            // If it's an instant "Back"/"Forward" navigation
            // then navigate to the page without loading it.
            // (has been previously preloaded and is in Redux state)
            var _isInstantTransition = location.action === 'POP' && previousLocation && (0, _instantNavigation.isInstantTransition)(previousLocation, location);

            // Set the flag for `wasInstantNavigation()`.
            (0, _instantNavigation.setInstantNavigationFlag)(_isInstantTransition);

            // Indicates whether an `instantBack` `<Link/>` has been clicked.
            // (or if `goto()` has been called with `instantBack: true` option)
            var instantBack = window._ReactPages_Page_IsInstantBackNavigation;

            // Update instant back navigation chain.
            if (instantBack) {
              // Stores "current" (soon to be "previous") location
              // in "instant back chain", so that if "Back" is clicked
              // then such transition could be detected as "should be instant".
              (0, _instantNavigation.addInstantBack)(location, previousLocation, routeIndices, previousRouteIndices);
            } else if (_isInstantTransition) {
              (0, _instantNavigation.updateInstantNavigationChainIndex)(location);
            } else {
              // If current transition is not "instant back" and not "instant"
              // then reset the whole "instant back" chain.
              // Only a consequitive "instant back" navigation chain
              // preserves the ability to instantly navigate "Back".
              // Once a regular navigation takes place
              // all previous "instant back" possibilities are discarded.
              (0, _instantNavigation.resetInstantNavigationChain)();
            }

            // Set the flag for `isInstantBackAbleNavigation()`.
            // `instantBack` is for a "forward" instant-back-able navigation.
            // `_isInstantTransition` is for a "backwards" instant-back-able navigation.
            if (instantBack || _isInstantTransition) {
              window._ReactPages_Page_NavigationIsInstantBack = true;
            }

            // When `UPDATE_MATCH` event is triggered, navigation starts.
            // When `RESOLVE_MATCH` event is triggered, navigation ends.
            // `RESOLVE_MATCH` event is triggered after `UPDATE_MATCH` event.
            //
            // Trigger navigation start listeners.
            if (window._ReactPages_Navigation_Start_Listeners) {
              var _iterator = _createForOfIteratorHelper(window._ReactPages_Navigation_Start_Listeners),
                _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var navigationStartListener = _step.value;
                  navigationStartListener();
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            }

            // // `RESOLVE_MATCH` is not being emitted
            // // for the first render for some reason.
            // // https://github.com/4Catalyzer/found/issues/202
            // const isFirstRender = !previousLocation
            // if (isFirstRender) {
            // 	updateMetaTags(
            // 		routeIndices,
            // 		getState(),
            // 		{
            // 			routes,
            // 			codeSplit,
            // 			defaultMeta: getDefaultMeta(defaultMeta, { getState })
            // 		}
            // 	)
            // } else {
            // 	// Show page loading indicator.
            // 	dispatch({ type: PRELOAD_STARTED })
            // }

            if (onBeforeNavigate) {
              onBeforeNavigate({
                dispatch: dispatch,
                getState: getState,
                location: event.payload.location,
                params: event.payload.params
              });
            }

            // Show page loading indicator.
            if (!(0, _flags.isServerSidePreloaded)() && !window._ReactPages_RouterHasFinishedInitialRender) {
              // Don't show page loading indicator
              // because it's already being shown manually.
            } else {
              // Show page loading indicator.
              dispatch({
                type: _actions.PRELOAD_STARTED
              });
            }
            break;

          // `UPDATE_MATCH` event is triggered when navigation starts.
          // `RESOLVE_MATCH` event is triggered when navigation ends.
          //
          // `RESOLVE_MATCH` is not being dispatched
          // for the first render for some reason.
          // https://github.com/4Catalyzer/found/issues/202
          // With server-side rendering enabled
          // initially there are two rendering passes
          // and therefore `RESOLVE_MATCH` does get dispatched
          // after the page is initialized and rendered.
          // With server-side rendering disabled
          // `RESOLVE_MATCH` does not get dispatched
          // therefore a custom `_RESOLVE_MATCH` event is
          // dispatched manually.
          case _index.RESOLVE_MATCH:
          case _index._RESOLVE_MATCH:
            if (window._ReactPages_Navigation_IgnoreResolveMatchEvent) {
              window._ReactPages_Navigation_IgnoreResolveMatchEvent = undefined;
              break;
            }

            // A workaround for `found` router bug:
            // https://github.com/4Catalyzer/found/issues/239
            // Skip `load` and other stuff for anchor link navigation.
            if (previousLocation && (0, _shouldSkipPreloadForNavigation["default"])(previousLocation, location)) {
              // I guess this workaround won't work with `codeSplit: true`
              // because it doesn't use the global `getData` loader.
              if (!codeSplit) {
                break;
              }
            }

            // `routeIndices` might be `undefined` after a `<Redirect/>`
            // is made and a user clicks the "Back" button in a web browser.
            // https://github.com/4Catalyzer/found/issues/632
            if (!routeIndices) {
              throw new Error("\"".concat(event.type, "\" Redux action misses \"routeIndices\" property. This usually means that the target URL path \"").concat(location.pathname, "\" didn't match any route. ").concat(location.pathname[0] !== '/' ? 'The target URL path is missing a leading slash: correct your routes configuration to include a leading slash for "' + location.pathname + '" path. ' : '', "See the issue for more info: https://github.com/4Catalyzer/found/issues/632"));
            }

            // `previousLocation` is only used for "instant back" navigation.
            // Therefore it can be skipped in case of anchor link navigation.
            previousLocation = location;
            previousRouteIndices = routeIndices;
            if (!window._ReactPages_RouterHasFinishedInitialRender) {
              window._ReactPages_RouterHasFinishedInitialRender = true;
            }

            // Call `onLoaded`.
            if (!codeSplit) {
              var routeChain = (0, _index.getRoutesByPath)(routeIndices, routes);
              var pageRoute = routeChain[routeChain.length - 1];
              // Routes don't have `.Component` property
              // set when using `codeSplit` feature.
              var onPageLoaded = pageRoute.Component[ON_PAGE_LOADED_METHOD_NAME];
              if (onPageLoaded) {
                onPageLoaded({
                  dispatch: dispatch,
                  getState: getState,
                  location: location
                });
              }
            }

            // Update `<meta/>`.
            updateMetaTags(routeIndices, getState(), {
              routes: routes,
              codeSplit: codeSplit,
              defaultMeta: (0, _getDefaultMeta["default"])(defaultMeta, {
                getState: getState
              })
            });
            if (onNavigate) {
              onNavigate((0, _getLocationUrl["default"])(location), location, {
                dispatch: dispatch,
                getState: getState
              });
            }

            // When `UPDATE_MATCH` event is triggered, navigation starts.
            // When `RESOLVE_MATCH` event is triggered, navigation ends.
            // `RESOLVE_MATCH` event is triggered after `UPDATE_MATCH` event.
            //
            // Trigger navigation end listeners.
            if (window._ReactPages_Navigation_End_Listeners) {
              var _iterator2 = _createForOfIteratorHelper(window._ReactPages_Navigation_End_Listeners),
                _step2;
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var navigationEndListener = _step2.value;
                  navigationEndListener();
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }
            //
            // Reset the flag for `isInstantBackAbleNavigation()`.
            window._ReactPages_Page_NavigationIsInstantBack = undefined;

            // Report page loading time.
            // This loading time will be longer then
            // the server-side one, say, by 10 milliseconds,
            // probably because the web browser making
            // an asynchronous HTTP request is slower
            // than the Node.js server making a regular HTTP request.
            // Also this includes network latency
            // for a particular website user, etc.
            // So this `load` time doesn't actually describe
            // the server-side performance.
            if (reportStats) {
              reportStats({
                url: (0, _getLocationUrl["default"])(location),
                // Concatenated route `path` string.
                // E.g. "/user/:user_id/post/:post_id"
                route: (0, _index.getRoutePath)((0, _index.getRoutesByPath)(routeIndices, routes)),
                time: {
                  loadAndRender: Date.now() - startedAt
                }
              });
            }

            // Hide page loading indicator.
            dispatch({
              type: _actions.PRELOAD_FINISHED
            });

            // Report loading time in console for debugging.
            if (Date.now() - startedAt > 30) {
              console.log("[react-pages] \"".concat(location.pathname, "\" loaded and rendered in ").concat(Date.now() - startedAt, " ms"));
            }
            break;
        }
        return next(event);
      };
    };
  };
}
function updateMetaTags(routeIndices, state, _ref2) {
  var routes = _ref2.routes,
    codeSplit = _ref2.codeSplit,
    defaultMeta = _ref2.defaultMeta;
  var routeChain = (0, _index.getRoutesByPath)(routeIndices, routes);
  // Get `<meta/>` for the route.
  var meta = codeSplit ? (0, _meta.getCodeSplitMeta)(routeChain, state) : (0, _meta.getComponentsMeta)(routeChain.map(function (_) {
    return _.Component;
  }), state);
  meta = (0, _meta.mergeMeta)(meta);
  meta = _objectSpread(_objectSpread({}, defaultMeta), meta);
  // Update `<meta/>`.
  (0, _meta.updateMeta)(meta);
}
//# sourceMappingURL=router.js.map