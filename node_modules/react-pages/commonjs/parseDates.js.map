{"version":3,"file":"parseDates.js","names":["hours","minutes","midnight_weird","seconds","milliseconds","time","timezone_hours","timezone_minutes","timezone","year","month","day","ISO_date_regexp","ISO_date_matcher","RegExp","parseDates","object","test","Date","Array","i","length","isObject","Object","keys","key"],"sources":["../lib/parseDates.js"],"sourcesContent":["import isObject from './isObject.js'\r\n\r\n// ISO 8601 date regular expression\r\n// Adapted from: http://stackoverflow.com/a/14322189/970769\r\n\r\nconst hours = '([01]\\\\d|2[0-3])'\r\nconst minutes = '[0-5]\\\\d'\r\nconst midnight_weird = '24\\\\:00'\r\nconst seconds = '[0-5]\\\\d'\r\nconst milliseconds = '\\\\d+'\r\nconst time = `(${hours}\\\\:${minutes}|${midnight_weird})\\\\:${seconds}([\\\\.,]${milliseconds})?`\r\n\r\nconst timezone_hours = `([01]\\\\d|2[0-3])`\r\nconst timezone_minutes = `[0-5]\\\\d`\r\nconst timezone = `([zZ]|([\\\\+-])${timezone_hours}\\\\:?(${timezone_minutes})?)`\r\n\r\nconst year = '\\\\d{4}'\r\nconst month = '(0[1-9]|1[0-2])'\r\nconst day = '([12]\\\\d|0[1-9]|3[01])'\r\n\r\nexport const ISO_date_regexp = `${year}-${month}-${day}T${time}${timezone}`\r\nexport const ISO_date_matcher = new RegExp('^' + ISO_date_regexp + '$')\r\n\r\n// JSON date deserializer.\r\n//\r\n// Automatically converts ISO serialized `Date`s\r\n// in JSON responses for Ajax HTTP requests.\r\n//\r\n// Without it the developer would have to convert\r\n// `Date` strings to `Date`s in Ajax HTTP responses manually.\r\n//\r\n// Use as the second, 'reviver' argument to `JSON.parse`: `JSON.parse(json, JSON.dateParser)`\r\n//\r\n// http://stackoverflow.com/questions/14488745/javascript-json-date-deserialization/23691273#23691273\r\n\r\n// Walks JSON object tree\r\nexport default function parseDates(object)\r\n{\r\n\t// If it's a date in an ISO string format, then parse it\r\n\tif (typeof object === 'string' && ISO_date_matcher.test(object))\r\n\t{\r\n\t\treturn new Date(object)\r\n\t}\r\n\t// If an array is encountered,\r\n\t// proceed recursively with each element of this array.\r\n\telse if (object instanceof Array)\r\n\t{\r\n\t\tlet i = 0\r\n\t\twhile (i < object.length)\r\n\t\t{\r\n\t\t\tobject[i] = parseDates(object[i])\r\n\t\t\ti++\r\n\t\t}\r\n\t}\r\n\t// If a child JSON object is encountered,\r\n\t// convert all of its `Date` string values to `Date`s,\r\n\t// and proceed recursively for all of its properties.\r\n\telse if (isObject(object))\r\n\t{\r\n\t\tfor (const key of Object.keys(object))\r\n\t\t{\r\n\t\t\t// proceed recursively\r\n\t\t\tobject[key] = parseDates(object[key])\r\n\t\t}\r\n\t}\r\n\r\n\t// Dates have been converted for this JSON object\r\n\treturn object\r\n}"],"mappings":";;;;;;;AAAA;AAAoC;AAEpC;AACA;;AAEA,IAAMA,KAAK,GAAG,kBAAkB;AAChC,IAAMC,OAAO,GAAG,UAAU;AAC1B,IAAMC,cAAc,GAAG,SAAS;AAChC,IAAMC,OAAO,GAAG,UAAU;AAC1B,IAAMC,YAAY,GAAG,MAAM;AAC3B,IAAMC,IAAI,cAAOL,KAAK,gBAAMC,OAAO,cAAIC,cAAc,iBAAOC,OAAO,oBAAUC,YAAY,OAAI;AAE7F,IAAME,cAAc,qBAAqB;AACzC,IAAMC,gBAAgB,aAAa;AACnC,IAAMC,QAAQ,2BAAoBF,cAAc,kBAAQC,gBAAgB,QAAK;AAE7E,IAAME,IAAI,GAAG,QAAQ;AACrB,IAAMC,KAAK,GAAG,iBAAiB;AAC/B,IAAMC,GAAG,GAAG,wBAAwB;AAE7B,IAAMC,eAAe,aAAMH,IAAI,cAAIC,KAAK,cAAIC,GAAG,cAAIN,IAAI,SAAGG,QAAQ,CAAE;AAAA;AACpE,IAAMK,gBAAgB,GAAG,IAAIC,MAAM,CAAC,GAAG,GAAGF,eAAe,GAAG,GAAG,CAAC;;AAEvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AACe,SAASG,UAAU,CAACC,MAAM,EACzC;EACC;EACA,IAAI,OAAOA,MAAM,KAAK,QAAQ,IAAIH,gBAAgB,CAACI,IAAI,CAACD,MAAM,CAAC,EAC/D;IACC,OAAO,IAAIE,IAAI,CAACF,MAAM,CAAC;EACxB;EACA;EACA;EAAA,KACK,IAAIA,MAAM,YAAYG,KAAK,EAChC;IACC,IAAIC,CAAC,GAAG,CAAC;IACT,OAAOA,CAAC,GAAGJ,MAAM,CAACK,MAAM,EACxB;MACCL,MAAM,CAACI,CAAC,CAAC,GAAGL,UAAU,CAACC,MAAM,CAACI,CAAC,CAAC,CAAC;MACjCA,CAAC,EAAE;IACJ;EACD;EACA;EACA;EACA;EAAA,KACK,IAAI,IAAAE,oBAAQ,EAACN,MAAM,CAAC,EACzB;IACC,gCAAkBO,MAAM,CAACC,IAAI,CAACR,MAAM,CAAC,kCACrC;MADK,IAAMS,GAAG;MAEb;MACAT,MAAM,CAACS,GAAG,CAAC,GAAGV,UAAU,CAACC,MAAM,CAACS,GAAG,CAAC,CAAC;IACtC;EACD;;EAEA;EACA,OAAOT,MAAM;AACd"}