"use strict";

exports.__esModule = true;
exports.default = exports.ScrollContext = void 0;

var _StateStorage = _interopRequireDefault(require("farce/StateStorage"));

var _react = _interopRequireDefault(require("react"));

var _scrollBehavior = _interopRequireDefault(require("scroll-behavior"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import type { Location, RenderArgs, Router } from 'found';
// import HttpError from 'found/HttpError';
const STORAGE_NAMESPACE = '@@scroll';

const ScrollContext = /*#__PURE__*/_react.default.createContext(null);

exports.ScrollContext = ScrollContext;

const defaultCreateScrollBehavior = config => new _scrollBehavior.default(config);

class ScrollManager extends _react.default.Component {
  constructor(props) {
    super(props);
    this.prevRenderArgs = null;

    this.shouldUpdateScroll = (prevRenderArgs, renderArgs) => {
      const {
        shouldUpdateScroll
      } = this.props;

      if (!shouldUpdateScroll) {
        return true;
      } // Hack to allow access to ScrollBehavior internals (e.g. stateStorage).


      return shouldUpdateScroll.call(this.scrollBehavior, prevRenderArgs, renderArgs);
    };

    this.registerScrollElement = (key, element) => {
      const {
        renderArgs
      } = this.props;
      this.scrollBehavior.registerElement(key, element, this.shouldUpdateScroll, renderArgs);
      return () => {
        this.scrollBehavior.unregisterElement(key);
      };
    };

    const {
      createScrollBehavior = defaultCreateScrollBehavior,
      renderArgs: _renderArgs
    } = props;
    const {
      router
    } = _renderArgs;
    this.scrollBehavior = createScrollBehavior({
      addNavigationListener: router.addNavigationListener,
      stateStorage: new _StateStorage.default(router, STORAGE_NAMESPACE),
      getCurrentLocation: () => this.props.renderArgs.location,
      shouldUpdateScroll: this.shouldUpdateScroll
    });
    this.scrollContext = {
      scrollBehavior: this.scrollBehavior,
      registerScrollElement: this.registerScrollElement
    };
    this.prevRenderArgs = null;
  }

  componentDidMount() {
    this.maybeUpdateScroll();
  }

  componentDidUpdate() {
    this.maybeUpdateScroll();
  }

  componentWillUnmount() {
    this.scrollBehavior.stop();
  }

  maybeUpdateScroll() {
    const {
      renderArgs
    } = this.props;
    const prevLocation = this.prevRenderArgs && this.prevRenderArgs.location;

    if (renderArgs.location === prevLocation || !(renderArgs.elements || renderArgs.error)) {
      // If the location hasn't actually changed, or if we're in a global
      // pending state, don't update the scroll position.
      return;
    }

    this.scrollBehavior.updateScroll(this.prevRenderArgs, renderArgs);
    this.prevRenderArgs = renderArgs;
  }

  render() {
    return /*#__PURE__*/_react.default.createElement(ScrollContext.Provider, {
      value: this.scrollContext
    }, this.props.children);
  }

}

var _default = ScrollManager;
exports.default = _default;